{"meta":{"title":"Farwary","subtitle":"farwary","description":"","author":"wwj","url":"https://wwwwjin.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-08-24T05:47:00.000Z","updated":"2021-08-24T05:47:38.091Z","comments":true,"path":"categories/index.html","permalink":"https://wwwwjin.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-08-24T05:47:51.000Z","updated":"2021-08-24T05:48:03.439Z","comments":true,"path":"tags/index.html","permalink":"https://wwwwjin.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-08-24T05:48:14.000Z","updated":"2021-08-24T05:48:26.344Z","comments":true,"path":"about/index.html","permalink":"https://wwwwjin.github.io/about/index.html","excerpt":"","text":""},{"title":"404","date":"2021-08-24T05:49:12.000Z","updated":"2021-08-24T05:49:25.690Z","comments":true,"path":"404/index.html","permalink":"https://wwwwjin.github.io/404/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring Boot源码概览","slug":"spring-boot-configurationClassPostProcessor","date":"2021-08-12T11:46:50.306Z","updated":"2021-08-24T03:16:56.126Z","comments":true,"path":"2021/08/12/spring-boot-configurationclasspostprocessor/","link":"","permalink":"https://wwwwjin.github.io/2021/08/12/spring-boot-configurationclasspostprocessor/","excerpt":"","text":"processConfigBeanDefinitions123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119public void processConfigBeanDefinitions(BeanDefinitionRegistry registry) &#123; List&lt;BeanDefinitionHolder&gt; configCandidates = new ArrayList&lt;&gt;(); // 获取已有的BeanDefinition名称 String[] candidateNames = registry.getBeanDefinitionNames(); //循环遍历 for (String beanName : candidateNames) &#123; //获取当前BeanDefinition BeanDefinition beanDef = registry.getBeanDefinition(beanName); //从日志推测 判断当前是否解析过 if (beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE) != null) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Bean definition has already been processed as a configuration class: &quot; + beanDef); &#125; &#125; // 判断是否可能为配置类 // 根据类上的注解判断配置类是FULL模式还是LITE模式 // @Configuration &amp;&amp; proxyBeanMethods=true FULL模式 // @Bean,@Component,@ComponentScan,@Import,@ImportResource这些注解，则为LITE。 else if (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, this.metadataReaderFactory)) &#123; configCandidates.add(new BeanDefinitionHolder(beanDef, beanName)); &#125; &#125; // Return immediately if no @Configuration classes were found // 如果没有@Configuration就返回 if (configCandidates.isEmpty()) &#123; return; &#125; // Sort by previously determined @Order value, if applicable // 排序 configCandidates.sort((bd1, bd2) -&gt; &#123; int i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition()); int i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition()); return Integer.compare(i1, i2); &#125;); // Detect any custom bean name generation strategy supplied through the enclosing application context // 确认BeanNameGenerator存在 SingletonBeanRegistry sbr = null; if (registry instanceof SingletonBeanRegistry) &#123; sbr = (SingletonBeanRegistry) registry; if (!this.localBeanNameGeneratorSet) &#123; BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton( AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR); if (generator != null) &#123; this.componentScanBeanNameGenerator = generator; this.importBeanNameGenerator = generator; &#125; &#125; &#125; //容器环境 if (this.environment == null) &#123; this.environment = new StandardEnvironment(); &#125; // Parse each @Configuration class // 解析 @Configuration（解析工厂，问题广播，环境，资源加载器，名称生成器，注册表） ConfigurationClassParser parser = new ConfigurationClassParser( this.metadataReaderFactory, this.problemReporter, this.environment, this.resourceLoader, this.componentScanBeanNameGenerator, registry); // 待解析 Set&lt;BeanDefinitionHolder&gt; candidates = new LinkedHashSet&lt;&gt;(configCandidates); // 已解析 Set&lt;ConfigurationClass&gt; alreadyParsed = new HashSet&lt;&gt;(configCandidates.size()); do &#123; // 开始解析 StartupStep processConfig = this.applicationStartup.start(&quot;spring.context.config-classes.parse&quot;); parser.parse(candidates); parser.validate(); Set&lt;ConfigurationClass&gt; configClasses = new LinkedHashSet&lt;&gt;(parser.getConfigurationClasses()); configClasses.removeAll(alreadyParsed); // Read the model and create bean definitions based on its content if (this.reader == null) &#123; this.reader = new ConfigurationClassBeanDefinitionReader( registry, this.sourceExtractor, this.resourceLoader, this.environment, this.importBeanNameGenerator, parser.getImportRegistry()); &#125; this.reader.loadBeanDefinitions(configClasses); alreadyParsed.addAll(configClasses); processConfig.tag(&quot;classCount&quot;, () -&gt; String.valueOf(configClasses.size())).end(); candidates.clear(); if (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123; String[] newCandidateNames = registry.getBeanDefinitionNames(); Set&lt;String&gt; oldCandidateNames = new HashSet&lt;&gt;(Arrays.asList(candidateNames)); Set&lt;String&gt; alreadyParsedClasses = new HashSet&lt;&gt;(); for (ConfigurationClass configurationClass : alreadyParsed) &#123; alreadyParsedClasses.add(configurationClass.getMetadata().getClassName()); &#125; for (String candidateName : newCandidateNames) &#123; if (!oldCandidateNames.contains(candidateName)) &#123; BeanDefinition bd = registry.getBeanDefinition(candidateName); if (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, this.metadataReaderFactory) &amp;&amp; !alreadyParsedClasses.contains(bd.getBeanClassName())) &#123; candidates.add(new BeanDefinitionHolder(bd, candidateName)); &#125; &#125; &#125; candidateNames = newCandidateNames; &#125; &#125; while (!candidates.isEmpty()); // Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes if (sbr != null &amp;&amp; !sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123; sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry()); &#125; if (this.metadataReaderFactory instanceof CachingMetadataReaderFactory) &#123; // Clear cache in externally provided MetadataReaderFactory; this is a no-op // for a shared cache since it&#x27;ll be cleared by the ApplicationContext. ((CachingMetadataReaderFactory) this.metadataReaderFactory).clearCache(); &#125; &#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码概览","slug":"spring-boot-invokeBeanFactoryPostProcessors","date":"2021-08-12T02:25:20.202Z","updated":"2021-08-12T10:51:55.059Z","comments":true,"path":"2021/08/12/spring-boot-invokebeanfactorypostprocessors/","link":"","permalink":"https://wwwwjin.github.io/2021/08/12/spring-boot-invokebeanfactorypostprocessors/","excerpt":"","text":"invokeBeanFactoryPostProcessors12345678910protected void invokeBeanFactoryPostProcessors(ConfigurableListableBeanFactory beanFactory) &#123; PostProcessorRegistrationDelegate.invokeBeanFactoryPostProcessors(beanFactory, getBeanFactoryPostProcessors()); // Detect a LoadTimeWeaver and prepare for weaving, if found in the meantime // (e.g. through an @Bean method registered by ConfigurationClassPostProcessor) if (!NativeDetector.inNativeImage() &amp;&amp; beanFactory.getTempClassLoader() == null &amp;&amp; beanFactory.containsBean(LOAD_TIME_WEAVER_BEAN_NAME)) &#123; beanFactory.addBeanPostProcessor(new LoadTimeWeaverAwareProcessor(beanFactory)); beanFactory.setTempClassLoader(new ContextTypeMatchClassLoader(beanFactory.getBeanClassLoader())); &#125;&#125; invokeBeanFactoryPostProcessors123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174public static void invokeBeanFactoryPostProcessors( ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors) &#123; // WARNING: Although it may appear that the body of this method can be easily // refactored to avoid the use of multiple loops and multiple lists, the use // of multiple lists and multiple passes over the names of processors is // intentional. We must ensure that we honor the contracts for PriorityOrdered // and Ordered processors. Specifically, we must NOT cause processors to be // instantiated (via getBean() invocations) or registered in the ApplicationContext // in the wrong order. // // Before submitting a pull request (PR) to change this method, please review the // list of all declined PRs involving changes to PostProcessorRegistrationDelegate // to ensure that your proposal does not result in a breaking change: // https://github.com/spring-projects/spring-framework/issues?q=PostProcessorRegistrationDelegate+is%3Aclosed+label%3A%22status%3A+declined%22 // Invoke BeanDefinitionRegistryPostProcessors first, if any. Set&lt;String&gt; processedBeans = new HashSet&lt;&gt;(); // 判断beanFactory是否为BeanDefinitionRegistry if (beanFactory instanceof BeanDefinitionRegistry) &#123; BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory; //存放常规的BeanFactoryPostProcessor List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = new ArrayList&lt;&gt;(); //存放BeanDefinitionRegistryPostProcessor类型的 List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = new ArrayList&lt;&gt;(); // 处理入参中的beanFactoryPostProcessors for (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123; if (postProcessor instanceof BeanDefinitionRegistryPostProcessor) &#123; BeanDefinitionRegistryPostProcessor registryProcessor = (BeanDefinitionRegistryPostProcessor) postProcessor; //执行postProcessBeanDefinitionRegistry方法 registryProcessor.postProcessBeanDefinitionRegistry(registry); //放入对应的集合 registryProcessors.add(registryProcessor); &#125; else &#123; //放入对应的集合 regularPostProcessors.add(postProcessor); &#125; &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // Separate between BeanDefinitionRegistryPostProcessors that implement // PriorityOrdered, Ordered, and the rest. // 本次要执行的BeanDefinitionRegistryPostProcessor List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = new ArrayList&lt;&gt;(); // First, invoke the BeanDefinitionRegistryPostProcessors that implement PriorityOrdered. // 从容器中找出实现BeanDefinitionRegistryPostProcessor接口的名称 String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; // 检查是否实现了PriorityOrdered接口 if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; //创建bean currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); //执行过的名称，防止重复执行 processedBeans.add(ppName); &#125; &#125; //排序 sortPostProcessors(currentRegistryProcessors, beanFactory); //添加到 registryProcessors（用于执行postProcessBeanFactory） registryProcessors.addAll(currentRegistryProcessors); //执行postProcessBeanDefinitionRegistry方法(这里ConfigurationClassPostProcessor执行了bean的装载) invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); // Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered. // 查找实现了BeanDefinitionRegistryPostProcessor的bean postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; //筛选没处理过并且继承了Ordered接口 if (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); &#125; &#125; //排序 sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); //执行postProcessBeanDefinitionRegistry方法 invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); // Finally, invoke all other BeanDefinitionRegistryPostProcessors until no further ones appear. // 筛选剩下的 实现了BeanDefinitionRegistryPostProcessors接口的bean boolean reiterate = true; while (reiterate) &#123; reiterate = false; postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, true, false); for (String ppName : postProcessorNames) &#123; if (!processedBeans.contains(ppName)) &#123; currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class)); processedBeans.add(ppName); //循环查找 reiterate = true; &#125; &#125; sortPostProcessors(currentRegistryProcessors, beanFactory); registryProcessors.addAll(currentRegistryProcessors); invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry, beanFactory.getApplicationStartup()); currentRegistryProcessors.clear(); &#125; // Now, invoke the postProcessBeanFactory callback of all processors handled so far. // 调用所有的BeanFactoryPostProcessors方法 invokeBeanFactoryPostProcessors(registryProcessors, beanFactory); // 调用入参里的常规的BeanFactoryPostProcessors方法 invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory); &#125; else &#123; // Invoke factory processors registered with the context instance. invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory); &#125; // Do not initialize FactoryBeans here: We need to leave all regular beans // uninitialized to let the bean factory post-processors apply to them! // 下面开始处理容器中的所有BeanFactoryPostProcessor String[] postProcessorNames = beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, true, false); // Separate between BeanFactoryPostProcessors that implement PriorityOrdered, // Ordered, and the rest. List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = new ArrayList&lt;&gt;(); List&lt;String&gt; orderedPostProcessorNames = new ArrayList&lt;&gt;(); List&lt;String&gt; nonOrderedPostProcessorNames = new ArrayList&lt;&gt;(); for (String ppName : postProcessorNames) &#123; if (processedBeans.contains(ppName)) &#123; // skip - already processed in first phase above &#125; else if (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123; priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class)); &#125; else if (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123; orderedPostProcessorNames.add(ppName); &#125; else &#123; nonOrderedPostProcessorNames.add(ppName); &#125; &#125; // First, invoke the BeanFactoryPostProcessors that implement PriorityOrdered. // 排序 sortPostProcessors(priorityOrderedPostProcessors, beanFactory); // 执行 invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory); // Next, invoke the BeanFactoryPostProcessors that implement Ordered. // 处理实现Ordered接口的 List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = new ArrayList&lt;&gt;(orderedPostProcessorNames.size()); for (String postProcessorName : orderedPostProcessorNames) &#123; orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; sortPostProcessors(orderedPostProcessors, beanFactory); invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory); // Finally, invoke all other BeanFactoryPostProcessors. // 处理没有继承PriorityOrdered 或者 Ordered的 List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = new ArrayList&lt;&gt;(nonOrderedPostProcessorNames.size()); for (String postProcessorName : nonOrderedPostProcessorNames) &#123; nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class)); &#125; invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory); // Clear cached merged bean definitions since the post-processors might have // modified the original metadata, e.g. replacing placeholders in values... // 清除元数据缓存（mergedBeanDefinitions、allBeanNamesByType、singletonBeanNamesByType）， // 因为后处理器可能已经修改了原始元数据，例如， 替换值中的占位符... beanFactory.clearMetadataCache(); &#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码概览","slug":"spring-boot-refreshContext","date":"2021-08-11T12:24:29.516Z","updated":"2021-08-12T02:26:03.247Z","comments":true,"path":"2021/08/11/spring-boot-refreshcontext/","link":"","permalink":"https://wwwwjin.github.io/2021/08/11/spring-boot-refreshcontext/","excerpt":"","text":"refreshContext12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; StartupStep contextRefresh = this.applicationStartup.start(&quot;spring.context.refresh&quot;); // Prepare this context for refreshing. 准备工作 prepareRefresh(); // Tell the subclass to refresh the internal bean factory. 告诉子类刷新bean工厂 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. 预处理加入一些bean prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. 允许子类实现对beanFactory的后置处理 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(&quot;spring.context.beans.post-process&quot;); // Invoke factory processors registered as beans in the context. // 调用bean中的工厂处理程序 invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(&quot;Exception encountered during context initialization - &quot; + &quot;cancelling refresh attempt: &quot; + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset &#x27;active&#x27; flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring&#x27;s core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); contextRefresh.end(); &#125; &#125;&#125; 行** invokeBeanFactoryPostProcessors(...)","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码概览","slug":"spring-boot-prepareContext","date":"2021-08-11T08:02:06.967Z","updated":"2021-08-24T03:18:43.617Z","comments":true,"path":"2021/08/11/spring-boot-preparecontext/","link":"","permalink":"https://wwwwjin.github.io/2021/08/11/spring-boot-preparecontext/","excerpt":"","text":"prepareContext123456789101112131415161718192021222324252627282930313233343536373839private void prepareContext(DefaultBootstrapContext bootstrapContext, ConfigurableApplicationContext context, ConfigurableEnvironment environment, SpringApplicationRunListeners listeners, ApplicationArguments applicationArguments, Banner printedBanner) &#123; //设置环境 context.setEnvironment(environment); //后置处理。如设置ConversionService postProcessApplicationContext(context); // ApplicationContextInitializer实现类的初始化 applyInitializers(context); // 通知监听者 listeners.contextPrepared(context); // 启动上下文的关闭通知,查看了没有对应的事件处理者 bootstrapContext.close(context); // 打印信息 if (this.logStartupInfo) &#123; logStartupInfo(context.getParent() == null); logStartupProfileInfo(context); &#125; // Add boot specific singleton beans 注册特定的启动beans ConfigurableListableBeanFactory beanFactory = context.getBeanFactory(); beanFactory.registerSingleton(&quot;springApplicationArguments&quot;, applicationArguments); if (printedBanner != null) &#123; beanFactory.registerSingleton(&quot;springBootBanner&quot;, printedBanner); &#125; if (beanFactory instanceof DefaultListableBeanFactory) &#123; ((DefaultListableBeanFactory) beanFactory) .setAllowBeanDefinitionOverriding(this.allowBeanDefinitionOverriding); &#125; if (this.lazyInitialization) &#123; context.addBeanFactoryPostProcessor(new LazyInitializationBeanFactoryPostProcessor()); &#125; // Load the sources 获取资源，可看作启动类 Set&lt;Object&gt; sources = getAllSources(); Assert.notEmpty(sources, &quot;Sources must not be empty&quot;); // 注册BeanDefinition load(context, sources.toArray(new Object[0])); // 通知 listeners.contextLoaded(context);&#125; 行10 listeners.contextPrepared(context)行36 Post not found: spring-boot-load load(context, sources.toArray(new Object[0]));","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码概览","slug":"spring-boot-configDataEnvironmentPostProcessor","date":"2021-08-09T04:00:16.418Z","updated":"2021-08-11T08:00:50.429Z","comments":true,"path":"2021/08/09/spring-boot-configdataenvironmentpostprocessor/","link":"","permalink":"https://wwwwjin.github.io/2021/08/09/spring-boot-configdataenvironmentpostprocessor/","excerpt":"","text":"ConfigDataEnvironmentPostProcessor12345678910111213141516171819202122232425@Overridepublic void postProcessEnvironment(ConfigurableEnvironment environment, SpringApplication application) &#123; postProcessEnvironment(environment, application.getResourceLoader(), application.getAdditionalProfiles());&#125;void postProcessEnvironment(ConfigurableEnvironment environment, ResourceLoader resourceLoader, Collection&lt;String&gt; additionalProfiles) &#123; try &#123; this.logger.trace(&quot;Post-processing environment to add config data&quot;); resourceLoader = (resourceLoader != null) ? resourceLoader : new DefaultResourceLoader(); getConfigDataEnvironment(environment, resourceLoader, additionalProfiles).processAndApply(); &#125; catch (UseLegacyConfigProcessingException ex) &#123; this.logger.debug(LogMessage.format(&quot;Switching to legacy config file processing [%s]&quot;, ex.getConfigurationProperty())); configureAdditionalProfiles(environment, additionalProfiles); postProcessUsingLegacyApplicationListener(environment, resourceLoader); &#125; &#125;ConfigDataEnvironment getConfigDataEnvironment(ConfigurableEnvironment environment, ResourceLoader resourceLoader, Collection&lt;String&gt; additionalProfiles) &#123; return new ConfigDataEnvironment(this.logFactory, this.bootstrapContext, environment, resourceLoader, additionalProfiles, this.environmentUpdateListener);&#125; ConfigDataEnvironment封装了ConfigDataEnvironment对象 123456789101112131415161718192021ConfigDataEnvironment(DeferredLogFactory logFactory, ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment, ResourceLoader resourceLoader, Collection&lt;String&gt; additionalProfiles, ConfigDataEnvironmentUpdateListener environmentUpdateListener) &#123; Binder binder = Binder.get(environment); UseLegacyConfigProcessingException.throwIfRequested(binder); this.logFactory = logFactory; this.logger = logFactory.getLog(getClass()); this.notFoundAction = binder.bind(ON_NOT_FOUND_PROPERTY, ConfigDataNotFoundAction.class) .orElse(ConfigDataNotFoundAction.FAIL); this.bootstrapContext = bootstrapContext; this.environment = environment; //从spring.factories中获取ConfigDataLocationResolver实现 this.resolvers = createConfigDataLocationResolvers(logFactory, bootstrapContext, binder, resourceLoader); this.additionalProfiles = additionalProfiles; this.environmentUpdateListener = (environmentUpdateListener != null) ? environmentUpdateListener : ConfigDataEnvironmentUpdateListener.NONE; //从spring.factories中获取所有的ConfigDataLoader并用反射进行实例化 this.loaders = new ConfigDataLoaders(logFactory, bootstrapContext, resourceLoader.getClassLoader()); //创建ConfigDataEnvironmentContributors对象，里面会根据spring.config.import / location等默认定位参数初始化Contributor this.contributors = createContributors(binder);&#125; processAndApply1234567891011121314151617181920void processAndApply() &#123; //封装导入对象 ConfigDataImporter importer = new ConfigDataImporter(this.logFactory, this.notFoundAction, this.resolvers,this.loaders); //注册Binder到bootstrap实例容器 registerBootstrapBinder(this.contributors, null, DENY_INACTIVE_BINDING); //加载和解析ConfigDataLocation -&gt; ConfigDataResource -&gt; ConfigData ,此时还没有导入到Environment中，执行完毕之后应该都是BOUND_IMPORT,且此时绑定了spring.config / spring.profiles相关的配置属性信息 ConfigDataEnvironmentContributors contributors = processInitial(this.contributors, importer); //创建云平台参数 ConfigDataActivationContext activationContext = createActivationContext( contributors.getBinder(null, BinderOption.FAIL_ON_BIND_TO_INACTIVE_SOURCE)); // 带入云平台参数迭代 contributors = processWithoutProfiles(contributors, importer, activationContext); //构建Profiles activationContext = withProfiles(contributors, activationContext); //带入Profiles迭代 contributors = processWithProfiles(contributors, importer, activationContext); //应用到Environment对象中 applyToEnvironment(contributors, activationContext, importer.getLoadedLocations(), importer.getOptionalLocations());&#125; withProcessedImports12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849ConfigDataEnvironmentContributors withProcessedImports(ConfigDataImporter importer, ConfigDataActivationContext activationContext) &#123; ImportPhase importPhase = ImportPhase.get(activationContext); this.logger.trace(LogMessage.format(&quot;Processing imports for phase %s. %s&quot;, importPhase, (activationContext != null) ? activationContext : &quot;no activation context&quot;)); ConfigDataEnvironmentContributors result = this; int processed = 0; while (true) &#123; //获取未处理的源 //何为未处理，即 1.contributor.getKind() == Kind.UNBOUND_IMPORT //2.没有ConfigDataProperties 并且 没有处理过（导入位置不为空并且children没有 importPhase 键值） //3.有ConfigDataProperties但是没有Activate对象 并且 没有处理过 //4.有ConfigDataProperties有Activate对象并且云平台相同并且包含在云平台的Profiles中 并且 没有处理过 // 配置文件中有spring.config.import会在bound时产生ConfigDataProperties ConfigDataEnvironmentContributor contributor = getNextToProcess(result, activationContext, importPhase); if (contributor == null) &#123; this.logger.trace(LogMessage.format(&quot;Processed imports for of %d contributors&quot;, processed)); return result; &#125; //处理当前配置中的spirng.import if (contributor.getKind() == Kind.UNBOUND_IMPORT) &#123; Iterable&lt;ConfigurationPropertySource&gt; sources = Collections .singleton(contributor.getConfigurationPropertySource()); PlaceholdersResolver placeholdersResolver = new ConfigDataEnvironmentContributorPlaceholdersResolver( result, activationContext, true); Binder binder = new Binder(sources, placeholdersResolver, null, null, null); ConfigDataEnvironmentContributor bound = contributor.withBoundProperties(binder); result = new ConfigDataEnvironmentContributors(this.logger, this.bootstrapContext, result.getRoot().withReplacement(contributor, bound)); continue; &#125; ConfigDataLocationResolverContext locationResolverContext = new ContributorConfigDataLocationResolverContext( result, contributor, activationContext); ConfigDataLoaderContext loaderContext = new ContributorDataLoaderContext(this); List&lt;ConfigDataLocation&gt; imports = contributor.getImports(); this.logger.trace(LogMessage.format(&quot;Processing imports %s&quot;, imports)); //将配置文件解析成ConfigData Map&lt;ConfigDataResolutionResult, ConfigData&gt; imported = importer.resolveAndLoad(activationContext, locationResolverContext, loaderContext, imports); this.logger.trace(LogMessage.of(() -&gt; getImportedMessage(imported.keySet()))); //更新当前的源的子节点 ConfigDataEnvironmentContributor contributorAndChildren = contributor.withChildren(importPhase, asContributors(imported)); //获取新的root节点。递归替换新节点 result = new ConfigDataEnvironmentContributors(this.logger, this.bootstrapContext, result.getRoot().withReplacement(contributor, contributorAndChildren)); processed++; &#125;&#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码","slug":"spring-boot-prepareEnvironment","date":"2021-08-08T04:47:45.646Z","updated":"2021-08-11T01:40:10.199Z","comments":true,"path":"2021/08/08/spring-boot-prepareenvironment/","link":"","permalink":"https://wwwwjin.github.io/2021/08/08/spring-boot-prepareenvironment/","excerpt":"","text":"prepareEnvironment123456789101112131415161718192021private ConfigurableEnvironment prepareEnvironment(SpringApplicationRunListeners listeners, DefaultBootstrapContext bootstrapContext, ApplicationArguments applicationArguments) &#123; //根据webApplicationType返回不同的对象 ConfigurableEnvironment environment = getOrCreateEnvironment(); //把可能的命令行参数加入到环境配置中 configureEnvironment(environment, applicationArguments.getSourceArgs()); //在环境中添加 名为configurationProperties的源 ConfigurationPropertySources.attach(environment); //通知环境准备好了 listeners.environmentPrepared(bootstrapContext, environment); DefaultPropertiesPropertySource.moveToEnd(environment); Assert.state(!environment.containsProperty(&quot;spring.main.environment-prefix&quot;), &quot;Environment prefix cannot be set via properties.&quot;); bindToSpringApplication(environment); if (!this.isCustomEnvironment) &#123; environment = new EnvironmentConverter(getClassLoader()).convertEnvironmentIfNecessary(environment, deduceEnvironmentClass()); &#125; ConfigurationPropertySources.attach(environment); return environment;&#125; 行10 listeners.environmentPrepared(bootstrapContext, environment);","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码","slug":"spring-boot-stepListeners","date":"2021-08-08T04:36:35.325Z","updated":"2021-08-24T05:24:17.912Z","comments":true,"path":"2021/08/08/spring-boot-steplisteners/","link":"","permalink":"https://wwwwjin.github.io/2021/08/08/spring-boot-steplisteners/","excerpt":"","text":"控制台程序下各个阶段通知的监听者 starting LoggingApplicationListener 获取日志系统，并做前置处理 BackgroundPreinitializer 啥也没做 DelegatingApplicationListener 啥也没做 environmentPrepared EnvironmentPostProcessorApplicationListener 环境后处理。将配置在“spring.factories”中EnvironmentPostProcessor 接口的实现类实例化并运行其 postProcessEnvironment 方法。（在此可以自我拓展） RandomValuePropertySourceEnvironmentPostProcessor 添加random到 propertySources SystemEnvironmentPropertySourceEnvironmentPostProcessor 把systemEnvironment的对象类型从SystemEnvironmentPropertySource 换成了 SystemEnvironmentPropertySourceEnvironmentPostProcessor$OriginAwareSystemEnvironmentPropertySource SpringApplicationJsonEnvironmentPostProcessor 将名为 spring.application.json 的json解析成map存入环境中 CloudFoundryVcapEnvironmentPostProcessor 云平台相关，不明白 ConfigDataEnvironmentPostProcessor 配置文件的读取 DebugAgentEnvironmentPostProcessor 调式代理 IntegrationPropertiesEnvironmentPostProcessor 集成配置加载 AnsiOutputApplicationListener 设置输出格式。根据spring.output.ansi.enabled的值来配置AnsiOutput LoggingApplicationListener 完成日志系统配置 BackgroundPreinitializer 加快应用初始化。后台线程初始化 DelegatingApplicationListener 将应用事件广播给环境属性context.listener.classes指定的那些监听器。 FileEncodingApplicationListener contextPrepared BackgroundPreinitializer 没有对应的事件，什么也没做 DelegatingApplicationListener 啥也没做 contextLoaded1.EnvironmentPostProcessorApplicationListener 把日志送到目的地2.LoggingApplicationListener3.BackgroundPreinitializer4.DelegatingApplicationListener","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码解读","slug":"spring-boot-deduceMainApplicationClass","date":"2021-08-07T02:49:40.866Z","updated":"2021-08-24T08:04:26.543Z","comments":true,"path":"2021/08/07/spring-boot-deducemainapplicationclass/","link":"","permalink":"https://wwwwjin.github.io/2021/08/07/spring-boot-deducemainapplicationclass/","excerpt":"","text":"deduceMainApplicationClassprivate Class&lt;?&gt; deduceMainApplicationClass() { try { StackTraceElement[] stackTrace = new RuntimeException().getStackTrace(); for (StackTraceElement stackTraceElement : stackTrace) { if (\"main\".equals(stackTraceElement.getMethodName())) { return Class.forName(stackTraceElement.getClassName()); } } } catch (ClassNotFoundException ex) { // Swallow and continue } return null; } 从栈中推断出启动类，依据是 main 函数","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码","slug":"spring-boot-simpleApplicationEventMulticaster","date":"2021-08-06T09:05:40.563Z","updated":"2021-08-07T04:23:38.406Z","comments":true,"path":"2021/08/06/spring-boot-simpleapplicationeventmulticaster/","link":"","permalink":"https://wwwwjin.github.io/2021/08/06/spring-boot-simpleapplicationeventmulticaster/","excerpt":"","text":"12345678910111213141516@Overridepublic void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) &#123; //解析事件类型 ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); //获取执行器 Executor executor = getTaskExecutor(); //筛选可以处理该事件的listeners for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123; if (executor != null) &#123; executor.execute(() -&gt; invokeListener(listener, event)); &#125; else &#123; invokeListener(listener, event); &#125; &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners( ApplicationEvent event, ResolvableType eventType) &#123; //这个事件源source即SpringApplication 对象 Object source = event.getSource(); Class&lt;?&gt; sourceType = (source != null ? source.getClass() : null); ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType); // Potential new retriever to populate CachedListenerRetriever newRetriever = null; // 根据事件源和事件从从缓存中查找对应的listeners CachedListenerRetriever existingRetriever = this.retrieverCache.get(cacheKey); if (existingRetriever == null) &#123; // 缓存 ListenerRetriever如果当前缓存中没有 if (this.beanClassLoader == null || (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &amp;&amp; (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) &#123; newRetriever = new CachedListenerRetriever(); existingRetriever = this.retrieverCache.putIfAbsent(cacheKey, newRetriever); if (existingRetriever != null) &#123; newRetriever = null; // no need to populate it in retrieveApplicationListeners &#125; &#125; &#125; if (existingRetriever != null) &#123; Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners(); if (result != null) &#123; return result; &#125; // If result is null, the existing retriever is not fully populated yet by another thread. // Proceed like caching wasn&#x27;t possible for this current local attempt. &#125; return retrieveApplicationListeners(eventType, sourceType, newRetriever); &#125; supportsEvent 未细看 listenerBeans推测是自己添加的监听器 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677private Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners( ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType, @Nullable CachedListenerRetriever retriever) &#123; List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = new ArrayList&lt;&gt;(); Set&lt;ApplicationListener&lt;?&gt;&gt; filteredListeners = (retriever != null ? new LinkedHashSet&lt;&gt;() : null); Set&lt;String&gt; filteredListenerBeans = (retriever != null ? new LinkedHashSet&lt;&gt;() : null); Set&lt;ApplicationListener&lt;?&gt;&gt; listeners; Set&lt;String&gt; listenerBeans; synchronized (this.defaultRetriever) &#123; listeners = new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListeners); listenerBeans = new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListenerBeans); &#125; // Add programmatically registered listeners, including ones coming // from ApplicationListenerDetector (singleton beans and inner beans). for (ApplicationListener&lt;?&gt; listener : listeners) &#123; if (supportsEvent(listener, eventType, sourceType)) &#123; if (retriever != null) &#123; filteredListeners.add(listener); &#125; allListeners.add(listener); &#125; &#125; // Add listeners by bean name, potentially overlapping with programmatically // registered listeners above - but here potentially with additional metadata. if (!listenerBeans.isEmpty()) &#123; ConfigurableBeanFactory beanFactory = getBeanFactory(); for (String listenerBeanName : listenerBeans) &#123; try &#123; if (supportsEvent(beanFactory, listenerBeanName, eventType)) &#123; ApplicationListener&lt;?&gt; listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class); if (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) &#123; if (retriever != null) &#123; if (beanFactory.isSingleton(listenerBeanName)) &#123; filteredListeners.add(listener); &#125; else &#123; filteredListenerBeans.add(listenerBeanName); &#125; &#125; allListeners.add(listener); &#125; &#125; else &#123; // Remove non-matching listeners that originally came from // ApplicationListenerDetector, possibly ruled out by additional // BeanDefinition metadata (e.g. factory method generics) above. Object listener = beanFactory.getSingleton(listenerBeanName); if (retriever != null) &#123; filteredListeners.remove(listener); &#125; allListeners.remove(listener); &#125; &#125; catch (NoSuchBeanDefinitionException ex) &#123; // Singleton listener instance (without backing bean definition) disappeared - // probably in the middle of the destruction phase &#125; &#125; &#125; AnnotationAwareOrderComparator.sort(allListeners); if (retriever != null) &#123; if (filteredListenerBeans.isEmpty()) &#123; retriever.applicationListeners = new LinkedHashSet&lt;&gt;(allListeners); retriever.applicationListenerBeans = filteredListenerBeans; &#125; else &#123; retriever.applicationListeners = filteredListeners; retriever.applicationListenerBeans = filteredListenerBeans; &#125; &#125; return allListeners; &#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码解读","slug":"spring-boot-getRunListeners","date":"2021-08-06T08:17:45.466Z","updated":"2021-08-24T13:20:03.927Z","comments":true,"path":"2021/08/06/spring-boot-getrunlisteners/","link":"","permalink":"https://wwwwjin.github.io/2021/08/06/spring-boot-getrunlisteners/","excerpt":"","text":"1.getRunListeners(String[] args)private SpringApplicationRunListeners getRunListeners(String[] args) { Class&lt;?&gt;[] types = new Class&lt;?&gt;[] { SpringApplication.class, String[].class }; return new SpringApplicationRunListeners(logger, getSpringFactoriesInstances(SpringApplicationRunListener.class, types, this, args), this.applicationStartup); } 获取实现了SpringApplicationRunListener接口的实例封装到SpringApplicationRunListeners 2.SpringApplicationRunListenersclass SpringApplicationRunListeners { private final Log log; // SpringApplicationRunListener接口实现类的集合包含 EventPublishingRunListener private final List&lt;SpringApplicationRunListener&gt; listeners; private final ApplicationStartup applicationStartup; SpringApplicationRunListeners(Log log, Collection&lt;? extends SpringApplicationRunListener&gt; listeners, ApplicationStartup applicationStartup) { this.log = log; this.listeners = new ArrayList&lt;&gt;(listeners); this.applicationStartup = applicationStartup; } /* 省略代码 */ private void doWithListeners(String stepName, Consumer&lt;SpringApplicationRunListener&gt; listenerAction, Consumer&lt;StartupStep&gt; stepAction) { StartupStep step = this.applicationStartup.start(stepName); //通知监听者 this.listeners.forEach(listenerAction); if (stepAction != null) { stepAction.accept(step); } step.end(); } } SpringApplicationRunListeners下发通知到EventPublishingRunListener 3.EventPublishingRunListenerpublic class EventPublishingRunListener implements SpringApplicationRunListener, Ordered { private final SpringApplication application; private final String[] args; // 简单事件分发器 private final SimpleApplicationEventMulticaster initialMulticaster; public EventPublishingRunListener(SpringApplication application, String[] args) { this.application = application; this.args = args; this.initialMulticaster = new SimpleApplicationEventMulticaster(); // 把监听者放入到 简单事件分发器 中 for (ApplicationListener&lt;?&gt; listener : application.getListeners()) { this.initialMulticaster.addApplicationListener(listener); } } /* 省略代码 */ EventPublishingRunListener 通过简单事件分发器对象分发事件 4.SimpleApplicationEventMulticasterpublic class SimpleApplicationEventMulticaster extends AbstractApplicationEventMulticaster { /* 省略代码 */ @Override public void multicastEvent(final ApplicationEvent event, @Nullable ResolvableType eventType) { // 事件类型 ResolvableType type = (eventType != null ? eventType : resolveDefaultEventType(event)); // 获取线程池 Executor executor = getTaskExecutor(); // 获取能处理此类事件的监听者并逐一通知 for (ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) { if (executor != null) { executor.execute(() -&gt; invokeListener(listener, event)); } else { invokeListener(listener, event); } } } } 5.AbstractApplicationEventMulticasterpublic abstract class AbstractApplicationEventMulticaster implements ApplicationEventMulticaster, BeanClassLoaderAware, BeanFactoryAware { private final DefaultListenerRetriever defaultRetriever = new DefaultListenerRetriever(); final Map&lt;ListenerCacheKey, CachedListenerRetriever&gt; retrieverCache = new ConcurrentHashMap&lt;&gt;(64); @Nullable private ClassLoader beanClassLoader; @Nullable private ConfigurableBeanFactory beanFactory; /* 省略代码 */ protected Collection&lt;ApplicationListener&lt;?&gt;&gt; getApplicationListeners( ApplicationEvent event, ResolvableType eventType) { //获取事件源 Object source = event.getSource(); //事件源的类型 Class&lt;?&gt; sourceType = (source != null ? source.getClass() : null); // 事件类型和事件源类型 组合成 key ListenerCacheKey cacheKey = new ListenerCacheKey(eventType, sourceType); // Potential new retriever to populate CachedListenerRetriever newRetriever = null; // 从缓存中查找处理此事件的监听者 CachedListenerRetriever existingRetriever = this.retrieverCache.get(cacheKey); // 不存在的话创建并缓存 if (existingRetriever == null) { // Caching a new ListenerRetriever if possible if (this.beanClassLoader == null || (ClassUtils.isCacheSafe(event.getClass(), this.beanClassLoader) &amp;&amp; (sourceType == null || ClassUtils.isCacheSafe(sourceType, this.beanClassLoader)))) { newRetriever = new CachedListenerRetriever(); existingRetriever = this.retrieverCache.putIfAbsent(cacheKey, newRetriever); if (existingRetriever != null) { newRetriever = null; // no need to populate it in retrieveApplicationListeners } } } if (existingRetriever != null) { Collection&lt;ApplicationListener&lt;?&gt;&gt; result = existingRetriever.getApplicationListeners(); if (result != null) { return result; } // If result is null, the existing retriever is not fully populated yet by another thread. // Proceed like caching wasn't possible for this current local attempt. } return retrieveApplicationListeners(eventType, sourceType, newRetriever); } /** * Actually retrieve the application listeners for the given event and source type. * @param eventType the event type * @param sourceType the event source type * @param retriever the ListenerRetriever, if supposed to populate one (for caching purposes) * @return the pre-filtered list of application listeners for the given event and source type */ private Collection&lt;ApplicationListener&lt;?&gt;&gt; retrieveApplicationListeners( ResolvableType eventType, @Nullable Class&lt;?&gt; sourceType, @Nullable CachedListenerRetriever retriever) { // 此次返回的所有监听者 List&lt;ApplicationListener&lt;?&gt;&gt; allListeners = new ArrayList&lt;&gt;(); // 能处理此次事件的监听者对象(理解为单例的) Set&lt;ApplicationListener&lt;?&gt;&gt; filteredListeners = (retriever != null ? new LinkedHashSet&lt;&gt;() : null); // 能处理此次事件的监听者对象的名称(理解为非单例的) Set&lt;String&gt; filteredListenerBeans = (retriever != null ? new LinkedHashSet&lt;&gt;() : null); Set&lt;ApplicationListener&lt;?&gt;&gt; listeners; Set&lt;String&gt; listenerBeans; synchronized (this.defaultRetriever) { listeners = new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListeners); listenerBeans = new LinkedHashSet&lt;&gt;(this.defaultRetriever.applicationListenerBeans); } // Add programmatically registered listeners, including ones coming // from ApplicationListenerDetector (singleton beans and inner beans). // 添加可以处理的监听者 for (ApplicationListener&lt;?&gt; listener : listeners) { if (supportsEvent(listener, eventType, sourceType)) { if (retriever != null) { filteredListeners.add(listener); } allListeners.add(listener); } } // Add listeners by bean name, potentially overlapping with programmatically // registered listeners above - but here potentially with additional metadata. // 根据类名判断是否可以处理当前事件并创建对应的实例 if (!listenerBeans.isEmpty()) { ConfigurableBeanFactory beanFactory = getBeanFactory(); for (String listenerBeanName : listenerBeans) { try { if (supportsEvent(beanFactory, listenerBeanName, eventType)) { ApplicationListener&lt;?&gt; listener = beanFactory.getBean(listenerBeanName, ApplicationListener.class); if (!allListeners.contains(listener) &amp;&amp; supportsEvent(listener, eventType, sourceType)) { if (retriever != null) { if (beanFactory.isSingleton(listenerBeanName)) { filteredListeners.add(listener); } else { filteredListenerBeans.add(listenerBeanName); } } allListeners.add(listener); } } else { // Remove non-matching listeners that originally came from // ApplicationListenerDetector, possibly ruled out by additional // BeanDefinition metadata (e.g. factory method generics) above. Object listener = beanFactory.getSingleton(listenerBeanName); if (retriever != null) { filteredListeners.remove(listener); } allListeners.remove(listener); } } catch (NoSuchBeanDefinitionException ex) { // Singleton listener instance (without backing bean definition) disappeared - // probably in the middle of the destruction phase } } } // 排序 AnnotationAwareOrderComparator.sort(allListeners); if (retriever != null) { if (filteredListenerBeans.isEmpty()) { retriever.applicationListeners = new LinkedHashSet&lt;&gt;(allListeners); retriever.applicationListenerBeans = filteredListenerBeans; } else { retriever.applicationListeners = filteredListeners; retriever.applicationListenerBeans = filteredListenerBeans; } } return allListeners; } private class CachedListenerRetriever { @Nullable public volatile Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners; @Nullable public volatile Set&lt;String&gt; applicationListenerBeans; } private class DefaultListenerRetriever { // 之前加载的ApplicationListener对象(单例的集合) public final Set&lt;ApplicationListener&lt;?&gt;&gt; applicationListeners = new LinkedHashSet&lt;&gt;(); // ApplicationListener对象的类名(非单例的集合) public final Set&lt;String&gt; applicationListenerBeans = new LinkedHashSet&lt;&gt;(); } } SpringApplicationRunListeners 在应用的不同阶段通知各个监听者 starting Called immediately when the run method has first started. Can be used for very early initialization. environmentPrepared Called once the environment has been prepared, but before the ApplicationContext has been created. contextPrepared Called once the ApplicationContext has been created and prepared, but before sources have been loaded. contextLoaded Called once the application context has been loaded but before it has been refreshed. started The context has been refreshed and the application has started but CommandLineRunners and ApplicationRunners have not been called. running Called immediately before the run method finishes, when the application context has been refreshed and all CommandLineRunners and ApplicationRunners have been called. failed Called when a failure occurs when running the application.","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码","slug":"spring-boot-eventPublishingRunListener","date":"2021-08-06T06:27:45.077Z","updated":"2021-08-07T04:23:44.701Z","comments":true,"path":"2021/08/06/spring-boot-eventpublishingrunlistener/","link":"","permalink":"https://wwwwjin.github.io/2021/08/06/spring-boot-eventpublishingrunlistener/","excerpt":"","text":"EventPublishingRunListener通过事件分发器（SimpleApplicationEventMulticaster）将当前事件分发给可以处理此类事件的listeners 1234567891011121314151617public class EventPublishingRunListener implements SpringApplicationRunListener, Ordered &#123; private final SpringApplication application; private final String[] args; private final SimpleApplicationEventMulticaster initialMulticaster; public EventPublishingRunListener(SpringApplication application, String[] args) &#123; this.application = application; this.args = args; this.initialMulticaster = new SimpleApplicationEventMulticaster(); for (ApplicationListener&lt;?&gt; listener : application.getListeners()) &#123; this.initialMulticaster.addApplicationListener(listener); &#125; &#125;","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码解读","slug":"spring-boot-getSpringFactoriesInstances","date":"2021-08-06T04:24:09.007Z","updated":"2021-08-24T08:04:32.789Z","comments":true,"path":"2021/08/06/spring-boot-getspringfactoriesinstances/","link":"","permalink":"https://wwwwjin.github.io/2021/08/06/spring-boot-getspringfactoriesinstances/","excerpt":"","text":"getSpringFactoriesInstancesprivate &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type) { return getSpringFactoriesInstances(type, new Class&lt;?&gt;[] {}); } private &lt;T&gt; Collection&lt;T&gt; getSpringFactoriesInstances(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args) { ClassLoader classLoader = getClassLoader(); //获取 META-INF/spring.factories 中实现对应 type 的类名 Set&lt;String&gt; names = new LinkedHashSet&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader)); //创建实例对象 List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names); //根据 @Order 排序 AnnotationAwareOrderComparator.sort(instances); //返回对象 return instances; } loadSpringFactoriesprivate static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(ClassLoader classLoader) { // 从缓存中查找有没有当前类加载器所加载过的结果集 Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader); // 有结果则返回结果 if (result != null) { return result; } result = new HashMap&lt;&gt;(); try { // 查找所有META-INF/spring.factories 文件 Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION); while (urls.hasMoreElements()) { URL url = urls.nextElement(); UrlResource resource = new UrlResource(url); // 加载文件 Properties properties = PropertiesLoaderUtils.loadProperties(resource); for (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) { // 获取接口类型名称 String factoryTypeName = ((String) entry.getKey()).trim(); // 实现类的名称集合 String[] factoryImplementationNames = StringUtils.commaDelimitedListToStringArray((String) entry.getValue()); // 将当前的实现类名放入对应的类型集合中 for (String factoryImplementationName : factoryImplementationNames) { result.computeIfAbsent(factoryTypeName, key -&gt; new ArrayList&lt;&gt;()) .add(factoryImplementationName.trim()); } } } // 对实现类名去重并返回不可修改的列表 result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct() .collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList))); // 缓存这个类加载器处理加载的结果 cache.put(classLoader, result); } catch (IOException ex) { throw new IllegalArgumentException(\"Unable to load factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); } return result; }","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码解读","slug":"spring-boot-deduceFromClasspath","date":"2021-08-06T04:21:44.477Z","updated":"2021-08-24T08:04:20.822Z","comments":true,"path":"2021/08/06/spring-boot-deducefromclasspath/","link":"","permalink":"https://wwwwjin.github.io/2021/08/06/spring-boot-deducefromclasspath/","excerpt":"","text":"deduceFromClasspath()static WebApplicationType deduceFromClasspath() { if (ClassUtils.isPresent(WEBFLUX_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(WEBMVC_INDICATOR_CLASS, null) &amp;&amp; !ClassUtils.isPresent(JERSEY_INDICATOR_CLASS, null)) { return WebApplicationType.REACTIVE; } for (String className : SERVLET_INDICATOR_CLASSES) { if (!ClassUtils.isPresent(className, null)) { return WebApplicationType.NONE; } } return WebApplicationType.SERVLET; } 根据相关类文件的存在与否判断程序类型 NONE就是什么都没有，按照正常的代码走即可不需要额外启动web容器如tomcat等；SERVLET则代表这是一个传统的servlet的web程序，对应SpringMVC，表示需要启动对应的web容器支持如tomcat等；REACTIVE则是一种比较新的非阻塞的web框架，对应spring-webflux，需要启动支持reactive的web容器","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]},{"title":"Spring Boot源码解读","slug":"srping-boot-app","date":"2021-08-06T04:19:17.907Z","updated":"2021-08-24T11:36:33.542Z","comments":true,"path":"2021/08/06/srping-boot-app/","link":"","permalink":"https://wwwwjin.github.io/2021/08/06/srping-boot-app/","excerpt":"","text":"说明Spring Boot 版本 2.5.3简单的控制台程序 程序入口 @SpringBootApplication public class App { public static void main(String[] args) { SpringApplication.run(App.class,args); } } public static ConfigurableApplicationContext run(Class&lt;?&gt;[] primarySources, String[] args) { return new SpringApplication(primarySources).run(args); } SpringApplication构造函数@SuppressWarnings({ \"unchecked\", \"rawtypes\" }) public SpringApplication(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources) { this.resourceLoader = resourceLoader; //判断主要资源是否为空 Assert.notNull(primarySources, \"PrimarySources must not be null\"); this.primarySources = new LinkedHashSet&lt;&gt;(Arrays.asList(primarySources)); //判断应用类型 this.webApplicationType = WebApplicationType.deduceFromClasspath(); //创建 BootstrapRegistryInitializer 接口实例 this.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories(); //创建 ApplicationContextInitializer 接口实例 setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class)); //创建 ApplicationListener 接口实例 setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class)); //推断程序入口类 this.mainApplicationClass = deduceMainApplicationClass(); } 判断应用类型 deduceFromClasspath()创建接口实例 getSpringFactoriesInstances(Class&lt;T&gt; type)推断程序入口 deduceMainApplicationClass() run方法public ConfigurableApplicationContext run(String... args) { StopWatch stopWatch = new StopWatch(); stopWatch.start(); //创建启动上下文，并执行了启动初始化(this.bootstrapRegistryInitializers) DefaultBootstrapContext bootstrapContext = createBootstrapContext(); //应用上下文 ConfigurableApplicationContext context = null; //设置系统属性 java.awt.headless configureHeadlessProperty(); //获取 SpringApplicationRunListener 接口实例(EventPublishingRunListener)集合封装成 SpringApplicationRunListeners SpringApplicationRunListeners listeners = getRunListeners(args); //通知开始 listeners.starting(bootstrapContext, this.mainApplicationClass); try { //应用启动参数 ApplicationArguments applicationArguments = new DefaultApplicationArguments(args); ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments); //设置忽略bean信息 configureIgnoreBeanInfo(environment); //打印Banner Banner printedBanner = printBanner(environment); //创建应用上下文 context = createApplicationContext(); //设置ApplicationStartup context.setApplicationStartup(this.applicationStartup); //准备应用上下文 prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner); //刷新 应用上下文 refreshContext(context); afterRefresh(context, applicationArguments); stopWatch.stop(); if (this.logStartupInfo) { new StartupInfoLogger(this.mainApplicationClass).logStarted(getApplicationLog(), stopWatch); } listeners.started(context); callRunners(context, applicationArguments); } catch (Throwable ex) { handleRunFailure(context, ex, listeners); throw new IllegalStateException(ex); } try { listeners.running(context); } catch (Throwable ex) { handleRunFailure(context, ex, null); throw new IllegalStateException(ex); } return context; } 行10 getRunListeners(args)及事件监听行16 prepareEnvironment(...)行27 prepareContext(...)行** refreshContext(...)","categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]}],"categories":[],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://wwwwjin.github.io/tags/Spring-Boot/"}]}